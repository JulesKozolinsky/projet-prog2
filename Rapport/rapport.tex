\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\title{Rapport du projet de programmtion 2}
\author{Jules Kozolinsky, Gabriel Lebouder, Julien Rixte}

\begin{document}
\maketitle

\section{Introduction}
Dans ce projet, nous avons du coder un jeu de type tower defense. Nous avons donc choisi de mettre en scène la protection d'une vallée contre des vagues de monstres ennemis. Pour cela, le joueur pourra construire des tours au dessus de la vallée afin de s'assurer que les monstres ne la traversent pas. 
\par
Nous avons subdivisé notre code en différents packages traitant chacun d'un aspect du problème. Nous expliquerons dans un premier temps le fonctionnement du jeu. Puis, nous présenterons les interactions entre nos packages. Enfin, nous verrons plus en détail l'organisation de chaque package.

\section{Fonctionnement du jeu}
Le jeu se déroule en différents niveaux. À chaque niveau, le joueur se voit attribuer un montant d'or et un nombre de vies. L'or permet de créer des tours. Le nombre de vies diminue lorsque des monstres parviennent à passer les défenses érigées par le joueur. Lorsque le joueur n'a plus de vie, il a perdu$_{the game}$.
\par
Chaque niveau consiste en une série de vagues de monstres précédées chacune d'une phase de positionnement défensif. Lors de la phase de positionnement, le joueur peut placer des tours de défense dans la limite de l'or disponible. Ces tours peuvent être de plusieurs type et certaines, bien que plus puissantes, peuvent coûter plus cher que d'autres. Une fois le positionnement effectué, le joueur peut lancer la vague de monstres en cliquant sur le bouton play.
\par
Les monstres vont alors essayer de passer outre les défenses du joueur. Chaque monstre tué rapporte un montant d'or proportionnel à la difficulté à tuer celui-ci. Pendant cette phase de jeu, il est impossible d'ajouter les tours. C'est pourquoi nous avons ajouté un bouton d'avance rapide permettant d'accélérer le jeu.
\par
À la fin du jeu, il suffit de cliquer sur l'image indiquant la défaite ou la victoire du joueur pour recommencer une partie.

\section{Interactions entre nos packages}
Nous avons choisi de diviser le code en trois parties principales : l'interface graphique (\textbf{gui}), le control du jeu (\textbf{game}) et la carte (\textbf{map}). L'idée derrière cette organisation était de cloisonner le plus possible différentes parties du codes afin qu'elles puissent fonctionner indépendemment. 
\par
Ainsi, afin que l'interface graphique puisse être changée aisément, aucun élément ayant trait à \textbf{gui} n'apparaît dans les autres parties du code. Pour cela, gui ne fait que lire les informations de \textbf{map} pour afficher les éléments de la carte et demande à \textbf{game} de s'actualiser lorsque cela est nécessaire. 
\par
TODO Un paragraphe sur les interactions entre \textbf{map} et \textbf{game}
\par
TODO à compléter
Une quatrième partie, \textbf{entities}, qui correspond à la configuration des tours et des monstres, dispose de classes permettant de créer facilement de nouveaux types de tours ou de monstres.
\section{Les différents packages}

\subsection{Entities}
Cette partie contient les définition des objets qui vont évoluer sur la map.\\
Ils sont subdivisés en classes comme montré ci-haut.\\
Les classes apparaissant plus haut sont toutes abstraites, on trouve en feuilles des arbres des classes instanciables (Tower1, Tower2, Monster5, Tower1Type, Monster6Type...).\\
les classes XXX1Type sont des objects
\subsection{Game}
\subsubsection{Round}
\subsubsection{Level}

\subsection{Parser}

\subsection{Map}
bonjour
messieurs jules et alix ça va bien ??

tututu
\subsection{Gui}

\begin{figure}[h]
\center
\includegraphics[scale = 0.4]{schema_gui.png}
\caption{Organisation de GUI}
\end{figure}

Le package \textbf{gui} contient l'interface graphique du jeu. Celle-ci a été écrite avec swing. L'objet principal est \textit{MainFrameGUI}. Il contient notamment la fonction actualize qui permet d'actualiser complètement \textbf{gui}. L'interface est alors séparée en deux parties : \textit{GameOptions} qui contient les options du jeu, situées en haut et \textit{GameGrid} qui contient la grille du jeu. \textit{GameOptions} est principalement constitué de boutons et d'informations sur le jeu. \textit{GameGrid} est le coeur de l'interface. C'est une grille qui peut contenir des \textit{MonsterCell} ou des \textit{TowerCell}. La fonction actualize de \textit{GameGrid} est la principale fonction d'actualisation de l'interface : c'est elle qui va lire la carte afin de placer les monstres et les tours à leur place.
\par
La gestion des images a posé de nombreux problèmes : en effet, nous n'avons pas trouvé d'autre moyen que de recharger le fichier image pour changer ses dimensions. Nous avons donc essayé de minimiser le nombre de fois où l'on change de taille d'image. De cette idée est née la classe \textit{Skin} qui permet un partage d'image entre les différentes entités de la grille et une évaluation paresseuse des différentes échelles dont on a besoin pour l'image. Cette classe permet donc de mettre autant de monstres qu'on le souhaite sur une même case sans pour autant ralentir de manière significative.


\section{Ce qu'on aimerait faire}

\end{document}